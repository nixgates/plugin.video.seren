# -*- coding: utf-8 -*-


# Below is the contents of the providers/__init__.py base64 encoded
# If you update this init file you will need to update this base64 as well to ensure it is deployed on the users machine
# If you change the init file without updating this it will be overwritten with the old one!!

init_contents = 'aW1wb3J0IG9zCmZyb20gcmVzb3VyY2VzLmxpYi5jb21tb24gaW1wb3J0IHRvb2xzCmZyb20gcmVzb3VyY2VzLmxpYi5tb2R1bGVzIGltcG9ydCBkYXRhYmFzZQoKZGF0YV9wYXRoID0gb3MucGF0aC5qb2luKHRvb2xzLmRhdGFQYXRoLCAncHJvdmlkZXJzJykKaG9zdGVyX3NvdXJjZXMgPSBbXQp0b3JyZW50X3NvdXJjZXMgPSBbXQoKZGVmIGdldF9yZWxldmFudChsYW5ndWFnZSk6CiAgICBwcm92aWRlcl9wYWNrYWdlcyA9IFtuYW1lIGZvciBuYW1lIGluIG9zLmxpc3RkaXIoZGF0YV9wYXRoKSBpZiBvcy5wYXRoLmlzZGlyKG9zLnBhdGguam9pbihkYXRhX3BhdGgsIG5hbWUpKV0KICAgICMgR2V0IHJlbGV2YW50IGFuZCBlbmFibGVkIHByb3ZpZGVyIGVudHJpZXMgZnJvbSB0aGUgZGF0YWJhc2UKICAgIHByb3ZpZGVyX3N0YXR1cyA9IFtpIGZvciBpIGluIGRhdGFiYXNlLmdldF9wcm92aWRlcnMoKSBpZiBpWydjb3VudHJ5J10gPT0gbGFuZ3VhZ2VdCiAgICBwcm92aWRlcl9zdGF0dXMgPSBbaSBmb3IgaSBpbiBwcm92aWRlcl9zdGF0dXMgaWYgaVsnc3RhdHVzJ10gPT0gJ2VuYWJsZWQnXQoKICAgIGZvciBwYWNrYWdlIGluIHByb3ZpZGVyX3BhY2thZ2VzOgogICAgICAgIHRyeToKICAgICAgICAgICAgcHJvdmlkZXJzX3BhdGggPSAncHJvdmlkZXJzLiVzLiVzJyAlIChwYWNrYWdlLCBsYW5ndWFnZSkKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgcHJvdmlkZXJfbGlzdCA9IF9faW1wb3J0X18ocHJvdmlkZXJzX3BhdGgsIGZyb21saXN0PVsnJ10pCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGZvciBpIGluIHByb3ZpZGVyX2xpc3QuZ2V0X2hvc3RlcnMoKToKICAgICAgICAgICAgICAgICAgICBmb3Igc3RhdHVzIGluIHByb3ZpZGVyX3N0YXR1czoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgaSA9PSBzdGF0dXNbJ3Byb3ZpZGVyX25hbWUnXToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHBhY2thZ2UgPT0gc3RhdHVzWydwYWNrYWdlJ106CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBBZGQgaW1wb3J0IHBhdGggYW5kIG5hbWUgdG8gaG9zdGVyX3Byb3ZpZGVycwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Rlcl9zb3VyY2VzLmFwcGVuZCgoJyVzLmhvc3RlcnMnICUgcHJvdmlkZXJzX3BhdGgsIGksIHBhY2thZ2UpKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgIAogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBmb3IgaSBpbiBwcm92aWRlcl9saXN0LmdldF90b3JyZW50KCk6CiAgICAgICAgICAgICAgICAgICAgZm9yIHN0YXR1cyBpbiBwcm92aWRlcl9zdGF0dXM6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGkgPT0gc3RhdHVzWydwcm92aWRlcl9uYW1lJ106CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwYWNrYWdlID09IHN0YXR1c1sncGFja2FnZSddOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgQWRkIGltcG9ydCBwYXRoIGFuZCBuYW1lIHRvIHRvcnJlbnRfcHJvdmlkZXJzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9ycmVudF9zb3VyY2VzLmFwcGVuZCgoJyVzLnRvcnJlbnQnICUgcHJvdmlkZXJzX3BhdGgsIGksIHBhY2thZ2UpKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBpbXBvcnQgdHJhY2ViYWNrCiAgICAgICAgICAgIHRyYWNlYmFjay5wcmludF9leGMoKQogICAgICAgICAgICBjb250aW51ZQoKICAgIHJldHVybiAodG9ycmVudF9zb3VyY2VzLCBob3N0ZXJfc291cmNlcykKCmRlZiBnZXRfYWxsKGxhbmd1YWdlKToKICAgIHByb3ZpZGVyX3BhY2thZ2VzID0gW25hbWUgZm9yIG5hbWUgaW4gb3MubGlzdGRpcihkYXRhX3BhdGgpIGlmIG9zLnBhdGguaXNkaXIob3MucGF0aC5qb2luKGRhdGFfcGF0aCwgbmFtZSkpXQogICAgZm9yIHBhY2thZ2UgaW4gcHJvdmlkZXJfcGFja2FnZXM6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBwcm92aWRlcnNfcGF0aCA9ICdwcm92aWRlcnMuJXMuJXMnICUgKHBhY2thZ2UsIGxhbmd1YWdlKQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBwcm92aWRlcl9saXN0ID0gX19pbXBvcnRfXyhwcm92aWRlcnNfcGF0aCwgZnJvbWxpc3Q9WycnXSkKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgZm9yIGkgaW4gcHJvdmlkZXJfbGlzdC5nZXRfaG9zdGVycygpOgogICAgICAgICAgICAgICAgICAgIGhvc3Rlcl9zb3VyY2VzLmFwcGVuZCgoJyVzLmhvc3RlcnMnICUgcHJvdmlkZXJzX3BhdGgsIGksIHBhY2thZ2UpKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBmb3IgaSBpbiBwcm92aWRlcl9saXN0LmdldF90b3JyZW50KCk6CiAgICAgICAgICAgICAgICAgICAgdG9ycmVudF9zb3VyY2VzLmFwcGVuZCgoJyVzLnRvcnJlbnQnICUgcHJvdmlkZXJzX3BhdGgsIGksIHBhY2thZ2UpKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCgogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgaW1wb3J0IHRyYWNlYmFjawogICAgICAgICAgICB0cmFjZWJhY2sucHJpbnRfZXhjKCkKICAgICAgICAgICAgY29udGludWUKCiAgICByZXR1cm4gKHRvcnJlbnRfc291cmNlcywgaG9zdGVyX3NvdXJjZXMpCg=='


import os
import sys
import json
import shutil
import base64
import requests
import xbmc

from resources.lib.common import tools
from resources.lib.modules import database


from resources.lib.modules import zfile as zipfile


class providers:
    def __init__(self):
        self.deploy_init()
        self.pre_update_collection = []
        # self.language = tools.getSetting('general.language')
        self.language = 'en'
        #tools.progressDialog.create(tools.addonName, 'Please Wait, Building Provider List')
        self.known_providers = database.get_providers()
        self.known_packages = database.get_provider_packages()
        self.update_known_providers()
        #tools.progressDialog.close()
        self.providers_path = os.path.join(tools.dataPath, 'providers')
        self.modules_path = os.path.join(tools.dataPath, 'providerModules')
        self.meta_path = os.path.join(tools.dataPath, 'providerMeta')

    def update_known_providers(self):
        provider_types = ['torrent', 'hosters']
        sys.path.append(tools.dataPath)
        import providers

        providers = providers.get_all(self.language)

        if len(self.pre_update_collection) > 0:
            pack_name = self.pre_update_collection[0]['package']

            hosters = providers[1]
            torrent = providers[0]

            for provider_type in range(len(provider_types)):
                for i in providers[provider_type]:
                    provider_name = i[1]

                    # We need to check that the provider file exists after updating
                    # For some reason lsdir still shows files as existing after the module removes them.
                    path = os.path.join(self.providers_path, pack_name, self.language,
                                        provider_types[provider_type], provider_name + ".py")

                    if not os.path.exists(path):
                        continue

                    old_setting = [x for x in self.pre_update_collection if
                                   x['provider_type'] == provider_types[provider_type] and
                                   x['package'] == pack_name and
                                   x['provider_name'] == provider_name]

                    if len(old_setting) > 0:
                        old_setting = old_setting[0]
                        database.add_provider(old_setting['provider_name'],
                                              old_setting['package'],
                                              old_setting['status'],
                                              old_setting['country'],
                                              old_setting['provider_type'])
                    else:
                        database.add_provider(i[1], i[2], 'enabled', self.language, provider_types[provider_type])

        else:
            if self.known_providers is None or len(self.known_providers) == 0:

                for provider in providers[0]:
                    tools.log('Adding Provider %s' % provider[1])
                    database.add_provider(provider[1], provider[2], 'enabled', self.language, 'torrent')
                for provider in providers[1]:
                    tools.log('Adding Provider %s' % provider[1])
                    database.add_provider(provider[1], provider[2], 'enabled', self.language, 'hoster')

            else:

                for i in range(2):
                    for provider in providers[i]:
                        existing = [existing for existing in self.known_providers
                                    if provider[2] == existing['package']\
                                    and provider[1] == existing['provider_name']\
                                    and existing['provider_type'] == provider_types[i]]


                        if len(existing) == 0:
                            tools.log('Adding Provider %s' % provider[1])
                            database.add_provider(provider[1], provider[2], 'enabled', self.language,
                                                  provider_types[i])
                            check = False


        self.known_providers = database.get_providers()

    def adjust_providers(self, status, package_disable=False):
        if status == 'disabled':
            action = 'enabled'
        if status == 'enabled':
            action = 'disabled'
        if len(self.known_providers) == 0:
            self.known_providers = database.get_providers()

        packages = list(set([pack['pack_name'] for pack in self.known_packages]))
        if len(packages) == 0:
            tools.showDialog.ok(tools.addonName, tools.lang(32074).encode('utf-8'))
            return
        selection = tools.showDialog.select("%s: %s Providers" %
                                            (tools.addonName, action[:-1].title()), packages)

        if selection == -1:
            return

        providers = [i for i in self.known_providers
                     if i['package'] == packages[selection]
                     and i['status'] == status
                     and i['country'] == self.language]

        if package_disable is False:
            display_list = ["%s - %s" % (tools.colorString(i['provider_name'].upper()), i['provider_type'].title())
                            for i in providers if i['status'] == status]

            selection = tools.showDialog.multiselect("%s: %s Providers" %
                                                     (tools.addonName, action[:-1].title()), display_list)

            if selection is None:
                return

            for i in selection:
                provider = providers[i]
                database.add_provider(provider['provider_name'], provider['package'], action, self.language,
                                      provider['provider_type'])

        elif package_disable is True:
            for i in providers:
                database.add_provider(i['provider_name'], i['package'], action, self.language, i['provider_type'])


    def uninstall_package(self):
        import shutil
        packages = [i['pack_name'] for i in self.known_packages]
        if len(packages) == 0:
            tools.showDialog.ok(tools.addonName, tools.lang(32074).encode('utf-8'))
            return
        selection = tools.showDialog.select("%s: %s Providers" %
                                            (tools.addonName, tools.lang(32075).encode('utf-8')), packages)
        if selection == -1:
            return
        package_name = packages[selection]
        confirm = tools.showDialog.yesno(tools.addonName, tools.lang(32076).encode('utf-8') + " %s" % package_name)
        if confirm == 0:
            return

        provider_path = os.path.join(self.providers_path, package_name)
        modules_path = os.path.join(self.modules_path, package_name)
        meta_path = os.path.join(self.meta_path, '%s.json' % package_name)
        if os.path.exists(provider_path):
            shutil.rmtree(provider_path)
        if os.path.exists(modules_path):
            shutil.rmtree(modules_path)
        if os.path.exists(meta_path):
            os.remove(meta_path)

        database.remove_package_providers(package_name)
        database.remove_provider_package(package_name)
        tools.showDialog.ok(tools.addonName, '%s ' % package_name + tools.lang(32077).encode('utf-8'))

    # -*- coding: utf-8 -*-

    def install_package(self, install_style):
        self.deploy_init()

        if install_style == None:

            install_style = tools.showDialog.select(tools.addonName, ['Browse...', 'Web Location...'])

        else:
            install_style = int(install_style)

        if install_style == 0:
            zip_location = tools.fileBrowser(1, 'Locate Provider Zip', 'files', '.zip', True, False)
        elif install_style == 1:
            zip_location = tools.showKeyboard('', '%s: Enter Zip URL' % tools.addonName)
            zip_location.doModal()
            if zip_location.isConfirmed() and zip_location.getText() != '':
                zip_location = zip_location.getText()
            else:
                return
        else:
            return

        zip_file = self.get_zip_file(zip_location)

        if zip_file is None:
            return

        self.install_zip(zip_file)

    def install_zip(self, zip_file, silent=False):
        file_list = zip_file.namelist()

        for i in file_list:
            if i.startswith('/') or '..' in i:
                raise Exception

        meta_file = None
        for i in file_list:
            if i.startswith('meta.json'):
                meta_file = i

        if meta_file is not None:
            meta = zip_file.open(meta_file)
            meta = meta.readlines()
            meta = ''.join(meta)
            meta = meta.replace(' ', '').replace('\r', '').replace('\n', '')
            meta = json.loads(meta)
            requirements = ['author', 'name', 'version']
            for i in requirements:
                if i not in meta:
                    if not silent:
                        self.failed_prompt()
                    tools.log('Source pack is malformed, please check and correct issue in the meta file')
                    return
            author = meta['author']
            version = meta['version']
            pack_name = meta['name']
            remote_meta = meta.get('remote_meta', '')
        else:
            if not silent:
                self.failed_prompt()
            tools.log('Source pack is malformed, please check and correct issue in the meta file')
            import traceback
            traceback.print_exc()
            raise Exception

        if remote_meta == '':
            tools.showDialog.ok(tools.addonName, tools.lang(33016).encode('utf-8'))

        line1 = tools.colorString(tools.lang(33001).encode('utf-8')) + " %s - v%s" % (pack_name, version)
        line2 = tools.colorString(tools.lang(33002).encode('utf-8')) + "%s" % author
        line3 = tools.lang(33003).encode('utf-8')

        if not silent:
            accept = tools.showDialog.yesno(tools.addonName + " - %s" % tools.lang(33004).encode('utf-8'),
                                            line1, line2, line3, tools.lang(33005).encode('utf-8'),
                                            tools.lang(33006).encode('utf-8'))
            if accept == 0:
                return

        self.pre_update_collection = [i for i in database.get_providers() if i['package'] == pack_name]

        database.remove_package_providers(pack_name)

        folders = ['providerModules/', 'providers/']
        meta_output_location = os.path.join(tools.dataPath, 'providerMeta', '%s.json' % pack_name)

        if os.path.isfile(meta_output_location):
            try:
                os.rename(meta_output_location, '%s.temp' % meta_output_location)
            except Exception as e:
                self.failure_cleanup(meta_output_location, pack_name, folders)
                tools.log('Failed to create temporary meta file')
                if not silent:
                    tools.showDialog.ok(tools.addonName, tools.lang(33007).encode('utf-8'))
                return

            try:
                self.output_meta(meta)
            except:
                self.failure_cleanup(meta_output_location, pack_name, folders)
                tools.log('Failed to create new meta file')
                if not silent:
                    self.failed_prompt()
                return

        else:
            self.output_meta(meta)

        if not silent:
            install_progress = tools.progressDialog
            install_progress.create(tools.addonName, '%s - %s' % (pack_name, tools.lang(33008).encode('utf-8')),
                                    tools.lang(33009).encode('utf-8'))
            install_progress.update(-1)

        try:
            for folder in folders:
                try:
                    folder_path = os.path.join(tools.dataPath, folder.strip('/'), pack_name)
                    if os.path.exists(folder_path):
                        os.rename(folder_path, '%s.temp' % folder_path)
                    for file in file_list:
                        if file.startswith(folder):
                            zip_file.extract(file, tools.dataPath)

                except:
                    tools.log('Failed to extract to folder - %s' % folder)
                    import traceback
                    traceback.print_exc()
                    self.failure_cleanup(meta_output_location, pack_name, folders)
                    if not silent:
                        self.failed_prompt()
                    return
            try:
                zip_file.close()
            except:
                pass

            if not silent:
                install_progress.close()
            if not silent:
                tools.showDialog.ok(tools.addonName, '%s - %s' % (tools.lang(33010).encode('utf-8'), pack_name))
        except:
            import traceback
            traceback.print_exc()
            if not silent:
                install_progress.close()
                tools.showDialog.ok(tools.addonName, '%s - %s' % (tools.lang(33012).encode('utf-8'), pack_name),
                                    tools.lang(33011).encode('utf-8'))
            return

        if os.path.exists('%s.temp' % meta_output_location):
            os.remove('%s.temp' % meta_output_location)
        for folder in folders:
            folder_path = os.path.join(tools.dataPath, folder.strip('/'), pack_name)
            if os.path.exists('%s.temp' % folder_path):
                shutil.rmtree('%s.temp' % folder_path)

        tools.log('Refreshing provider database ')
        database.add_provider_package(pack_name, author, remote_meta, version)

        self.update_known_providers()
        return True

    def failed_prompt(self):
        tools.showDialog.ok(tools.addonName, tools.lang(33013).encode('utf-8'), tools.lang(33011).encode('utf-8'))

    def deploy_init(self):
        folders = ['providerModules/', 'providers/']
        root_init_path = os.path.join(tools.dataPath, '__init__ .py')

        if not os.path.exists(tools.dataPath):
            os.makedirs(tools.dataPath)
        if not os.path.exists(root_init_path):
            open(root_init_path, 'a').close()
        for i in folders:
            folder_path = os.path.join(tools.dataPath, i)
            if not os.path.exists(folder_path):
                os.makedirs(folder_path)
            open(os.path.join(folder_path, '__init__.py'), 'a').close()
        provider_init = open(os.path.join(tools.dataPath, 'providers', '__init__.py'), 'w+')
        provider_init.write(base64.b64decode(init_contents))

    def output_meta(self, meta):
        try:
            output_directory = os.path.join(tools.dataPath, 'providerMeta')
            output_file = os.path.join(tools.dataPath, 'providerMeta', '%s.json' % meta['name'])

            if not os.path.exists(output_directory):
                os.mkdir(output_directory)

            if os.path.exists(output_file):
                os.rename(output_file, '%s.temp' % output_file)

            new_meta_file = open(output_file, 'w+')
            new_meta_file.write(json.dumps(meta))
            new_meta_file.close()
        except Exception as e:
            tools.log('Failed to create new meta file for provider')
            import traceback
            traceback.print_exc()
            raise Exception

    def get_zip_file(self, zip_location, silent=False):
        # This function processes any requests for zip files

        if zip_location == '':
            return

        if zip_location.startswith('special://'):
            zip_location = xbmc.translatePath(zip_location)

        if zip_location.startswith('smb'):
            if not silent:
                tools.showDialog.ok(tools.addonName, tools.lang(33014).encode('utf-8'))
            return

        if zip_location.startswith('http'):
            response = requests.get(zip_location, stream=True)
            if not response.ok and not silent:
                tools.showDialog.ok(tools.addonName, tools.lang(33015).encode('utf-8'))
                return
            else:
                pass
            try:
                import StringIO
                file = zipfile.ZipFile(StringIO.StringIO(response.content))
            except:
                # Python 3 Support
                import io
                file = zipfile.ZipFile(io.BytesIO(response.content))
        else:
            file = zipfile.ZipFile(zip_location)

        return file

    def failure_cleanup(self, meta_loction, package_name, folders):
        # In the event of a failure to install package this function will revert changes made

        tools.log('Reverting changes')
        try:
            if os.path.exists('%s.temp' % meta_loction):
                os.remove(meta_loction)
                os.rename('%s.temp' % meta_loction, meta_loction)
        except:
            pass

        for folder in folders:
            folder_path = os.path.join(tools.dataPath, folder.strip('/'), package_name)
            if os.path.exists('%s.temp' % folder_path):
                try:
                    shutil.rmtree(folder_path)
                except:
                    pass
                os.rename('%s.temp' % folder_path, folder_path)
        pass

    def check_for_updates(self, silent=False, automatic=False):
        # Automatic "True" will update all packages with available updates
        # Silent "True" will prevent kodi from creating any dialogs except for a single notification

        if not silent:
            update_dialog = tools.progressDialog
            update_dialog.create(tools.addonName, tools.lang(33019).encode('utf-8'))
            update_dialog.update(-1)

        updates = []

        packages = self.known_packages

        if len(packages) == 0:
            return

        for package in packages:
            if package['remote_meta'] == '':
                continue

            meta_file = requests.get(package['remote_meta'])
            if meta_file.status_code != 200:
                continue

            meta_file = json.loads(meta_file.text)
            if not meta_file['name'] == package['pack_name']:
                tools.log('Pack name check failure')
                continue
            if not self.check_version_numbers(package['version'], meta_file['version']):
                continue
            if not automatic:
                updates.append(meta_file)
            else:
                self.update(meta_file, silent)

        if not silent:
            update_dialog.close()

        if not automatic:
            return updates

    def update(self, meta_file, silent=False):
        # Hanldes the updating of a package

        update_directory = meta_file['update_directory']
        package_name = meta_file['name']
        version = meta_file['version']
        zip_file = '%s%s-%s.zip' % (update_directory, package_name, version)
        zip_file = self.get_zip_file(zip_file, silent=True)
        if zip_file is None:
            return
        result = self.install_zip(zip_file, silent=silent)
        if result is not None:
            tools.showDialog.notification(tools.addonName, tools.lang(33017).encode('utf-8') % package_name)

    def check_version_numbers(self, current, new):
        # Compares version numbers and return True if version is newer
        current = current.split('.')
        new = new.split('.')
        step = 0
        for i in current:
            if int(new[step]) > int(i):
                return True
            if int(i) == int(new[step]):
                step += 1
                continue

        return False

    def manual_update(self):
        updateable = self.check_for_updates()

        # If there are no available updates return
        if len(updateable) == 0:
            tools.showDialog.ok(tools.addonName, tools.lang(33018).encode('utf-8'))
            return

        # Display available packages to update
        display_list = ['%s - %s' % (i['name'], i['version']) for i in updateable]
        selection = tools.showDialog.select(tools.addonName, display_list)

        if selection == -1:
            return

        selection = updateable[selection]

        self.update(selection)

